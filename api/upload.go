// Package that contains the models of the JSON objects used in the requests and responses and the methods to create
// new objects that describes the API actions, like the Upload or the AtTokenScraper
package api

import (
	"net/http"
	"fmt"
	"encoding/json"
	"os"
	"bytes"
	"net/url"
	"strings"
	"github.com/simonedegiacomi/gphotosuploader/auth"
	"errors"
	"io"
	"time"
)

const (
	// Url to which send the request to get a new url to upload a new image
	NewUploadUrl = "https://photos.google.com/_/upload/uploadmedia/rupio/interactive?authuser=2"

	// Url to which send the request to enable an uploaded image
	EnablePhotoUrl = "https://photos.google.com/_/PhotosUi/mutate"

	// Key to send in the request to enable the image
	EnablePhotoKey = 137530650
)

// Structure that contains the Upload options
type UploadOptions struct {

	// Required field, a stream from which read the image.
	// You need to close the stream when the image is uploaded
	Stream	io.Reader

	// Required field, size of the photo
	FileSize     int64

	// Name of the photo (optional)
	Name         string

	// UNIX timestamp of the photo (optional)
	Timestamp    int64
}

// Create a new UploadOptions from a file
func NewUploadOptionsFromFile (file *os.File) (*UploadOptions, error) {
	info, err := file.Stat()
	if err != nil {
		return nil, fmt.Errorf("Can't read file information (%v)", err)
	}

	return &UploadOptions{
		Stream: file,
		FileSize: info.Size(),

		Name: file.Name(),
		Timestamp: info.ModTime().Unix(),
	}, nil
}

// Structure that represents an upload, generated by an UploadOptions
type Upload struct {
	// Options of the upload
	Options     *UploadOptions

	// Credentials to used to send the requests
	Credentials auth.Credentials

	// URl to which send the request with the image (the real upload)
	url         string
}

// Create a new Upload given an UploadOptions and a Credentials implementation. This method return an error if the
// upload options struct it's not usable to create a new upload
func NewUpload(options *UploadOptions, credentials auth.Credentials) (*Upload, error) {
	if options.Stream == nil {
		return nil, errors.New("The stream of the UploadOptions is nil")
	}
	if options.FileSize <= 0 {
		return nil, errors.New("The fileSize of the UploadOptions is <= 0")
	}

	// Fill missing optional fields
	if options.Name == "" {
		options.Name = time.Now().String()
	}
	if options.Timestamp < 0 {
		options.Timestamp = time.Now().Unix()
	}

	return &Upload{
		Options: options,
		Credentials: credentials,
	}, nil
}

// This method tries to upload an image, making multiple http requests
func (u *Upload) TryUpload() error {

	// First request to get the upload url
	err := u.requestUploadUrl()
	if err != nil {
		return errors.New("Can't request an upload url")
	}

	// Upload the real image file
	res, err := u.uploadFile()
	if err != nil {
		return errors.New("Can't upload file")
	}

	// Enable the photo
	err = u.enablePhoto(res)
	if err != nil {
		return err
	}

	// No errors, image uploaded!
	return nil
}


// Method that send a request with the file name and size to generate an  upload url.
// This method returns the url or an error
func (u *Upload) requestUploadUrl() error {

	// Prepare json request
	jsonReq := RequestUploadURL{
		ProtocolVersion: "0.8",
		CreateSessionRequest: CreateSessionRequest{
			Fields: []interface{}{
				ExternalField{
					External: ExternalFieldObject{
						Name: "file",
						Filename: u.Options.Name,
						Size: u.Options.FileSize,
					},
				},


				// Additional fields
				InlinedField{
					Inlined: InlinedFieldObject{
						Name: "auto_create_album",
						Content: "camera_sync.active",
						ContentType: "text/plain",
					},
				},
				InlinedField{
					Inlined: InlinedFieldObject{
						Name: "auto_downsize",
						Content: "true",
						ContentType: "text/plain",
					},
				},
				InlinedField{
					Inlined: InlinedFieldObject{
						Name: "storage_policy",
						Content: "use_manual_setting",
						ContentType: "text/plain",
					},
				},
				InlinedField{
					Inlined: InlinedFieldObject{
						Name: "disable_asbe_notification",
						Content: "true",
						ContentType: "text/plain",
					},
				},
				InlinedField{
					Inlined: InlinedFieldObject{
						Name: "client",
						Content: "photoweb",
						ContentType: "text/plain",
					},
				},
				InlinedField{
					Inlined: InlinedFieldObject{
						Name: "effective_id",
						Content: u.Credentials.GetPersistentParameters().UserId,
						ContentType: "text/plain",
					},
				},
				InlinedField{
					Inlined: InlinedFieldObject{
						Name: "owner_name",
						Content: u.Credentials.GetPersistentParameters().UserId,
						ContentType: "text/plain",
					},
				},

			},
		},
	}

	// Create http request
	jsonStr, err := json.Marshal(jsonReq)
	req, err := http.NewRequest("POST", NewUploadUrl, bytes.NewBuffer(jsonStr))
	if err != nil {
		return errors.New(fmt.Sprintf("Can't create upload URL request: %v", err.Error()))
	}

	// Add headers for the request
	req.Header.Add("x-guploader-client-info", "mechanism=scotty xhr resumable; clientVersion=156351954")

	// Make the request
	res, err := u.Credentials.GetClient().Do(req)
	if err != nil {
		return errors.New(fmt.Sprintf("Error during the request to get the upload URL: %v", err.Error()))
	}
	defer res.Body.Close()

	// PArse the json response
	jsonResponse := UploadURLRequestResponse{}
	if err := json.NewDecoder(res.Body).Decode(&jsonResponse); err != nil {
		return errors.New(fmt.Sprintf("Can't parse json response for upload URL request: %v", err.Error()))
	}

	if len(jsonResponse.SessionStatus.ExternalFieldTransfers) <= 0 {
		return errors.New("An array of the request URL response is empty")
	}

	// Set the URL to which upload the file
	u.url = jsonResponse.SessionStatus.ExternalFieldTransfers[0].PutInfo.Url
	return nil
}

// This method upload the file to the URL received from requestUploadUrl.
// When the upload is completed, the method updates the base64UploadToken field
func (u *Upload) uploadFile() (*UploadImageResponse, error) {
	if u.url == "" {
		return nil, errors.New("The url field is empty, make sure to call requestUploadUrl first")
	}

	// Create the request
	req, err := http.NewRequest("POST", u.url, u.Options.Stream)
	if err != nil {
		return nil, errors.New(fmt.Sprintf("Can't create upload URL request: %v", err.Error()))
	}

	// Prepare request headers
	req.Header.Add("content-type", "application/octet-stream")
	req.Header.Add("content-length", fmt.Sprintf("%v", u.Options.FileSize))
	req.Header.Add("X-HTTP-Method-Override", "PUT")


	// Upload the image
	res, err := u.Credentials.GetClient().Do(req)
	if err != nil {
		return nil, errors.New(fmt.Sprintf("Can't upload the image, got: %v", err))
	}
	defer res.Body.Close()

	// Parse the response
	jsonRes := &UploadImageResponse{}
	if err := json.NewDecoder(res.Body).Decode(&jsonRes); err != nil {
		return nil, err
	}
	return jsonRes, nil
}

// Request that enables the image once it gets uploaded
func (u *Upload) enablePhoto(uploadResponse *UploadImageResponse) error {

	// Form that contains the two request field
	form := url.Values{}

	// First form field
	uploadTokenBase64 := uploadResponse.SessionStatus.AdditionalInfo.UploadService.CompletionInfo.CustomerSpecificInfo.UploadTokenBase64
	mapOfItems := MapOfItemsToEnable{}
	jsonReq := EnableImageRequest{
		"af.maf",
		[]FirstItemEnableImageRequest{
			[]InnerItemFirstItemEnableImageRequest{
				"af.add",
				EnablePhotoKey,
				SecondInnerArray{
					mapOfItems,
				},
			},
		},

	}
	mapOfItems[fmt.Sprintf("%v", EnablePhotoKey)] = ItemToEnable{
		ItemToEnableArray{
			[]InnerItemToEnableArray{
				uploadTokenBase64,
				u.Options.Name,
				u.Options.Timestamp,
			},
		},
	}

	// Stringify the first field
	jsonStr, err := json.Marshal(jsonReq)
	if err != nil {
		panic(err)
	}

	// And add it to the form
	form.Add("f.req", string(jsonStr))


	// Second field of the form: "at", which should be an API key or something
	form.Add("at", u.Credentials.GetRuntimeParameters().AtToken)

	// Create the request
	req, err := http.NewRequest("POST", EnablePhotoUrl, strings.NewReader(form.Encode()))
	if err != nil {
		return errors.New(fmt.Sprintf("Can't create the request to enable the image: %v", err.Error()))
	}

	// Add headers
	req.Header.Add("content-type", "application/x-www-form-urlencoded;charset=UTF-8")

	// Send the request
	res, err := u.Credentials.GetClient().Do(req)
	if err != nil {
		return errors.New(fmt.Sprintf("Error during the request to enable the image: %v", err.Error()))
	}
	defer res.Body.Close()

	// Image enabled
	return nil
}
